---
title: Codeur rotatif et afficheur 7 segments sous RaspberryPi
permalink: raspberryPi-codeurRotatif-afficheur7segments-led
layout: post
date: 2015-05-15 20:31:00
tags: [raspberryPi, python, rotaryEncoder, led]
category: raspberryPi
---

Dans cet article, on va décrire comment faire fonctionner un codeur rotatif
pour piloter un affichier LED à sept segments.
Le but est le suivant 
- L'appui sur le bouton central, allume ou éteint l'afficheur LED
- La rotation dans le sens des aiguilles d'une montre incrémente 
  le compteur qui s'affiche avec un maximum à 9
- La rotation dans le sens inverse des aiguilles d'une montre décrémente
  le compteur qui s'affiche avec un minimum à 0


## Fonctionnement du codeur rotatif

On commence par vérifier le fonctionnement de l'encodeur rotatif en
affichant des messages à l'écran.


### Les connexions

D'abord les branchements

Rotary encoder | Raspberry Pi
---------------|-------------
           CLK | GPIO 21
            DT | GPIO 20
            SW | GPIO 16
             + | GPIO 5V
           GND | GPIO Ground

![rotary]({{ site.baseurl }}/images/7segments/rotary.png)


### Le code

Il existe de nombreuses façons de programmer l'intéraction avec le codeur
rotatif. Ici on va se baser sur la classe `RotaryEncoder` de Bob Rathbone.


```
$ wget https://raw.githubusercontent.com/bobrathbone/pirotary/master/rotary_class.py
```

Une fois le fichier `rotary_class.py` déposé dans le bon dossier,
ouvrons leafpad pour écrire le programme suivant qu'on nomme `rotary.py`


```python
from rotary_class import RotaryEncoder
from time import sleep

# Define GPIO inputs
SW = 16
DT = 20
CLK = 21

# Fonction de callback qui agit selon les evenements
def switch_event(event):
        if event == RotaryEncoder.CLOCKWISE:
              print("Plus")
              sleep(.2)
        elif event == RotaryEncoder.ANTICLOCKWISE:
              print("Moins")
              sleep(.2)
        elif event == RotaryEncoder.BUTTONDOWN:
              print("Bdown")
        return

# Definit la détection de front
rswitch = RotaryEncoder(CLK,DT,SW,switch_event)

try:
  print("Le programme fonctionne pendant 60s.")
  sleep(60)

except KeyboardInterrupt:
  print("\nInterruption par clavier.")

finally:
  print("On arrete tout")
```

On peut maintenant lancer le programme 

```
$ sudo python rotary.py
```

et observer la console lorsqu'on agit sur
le codeur en appuyant sur le poussoir ou tournant dans un sens ou dans l'autre.


## Fonctionnement de l'afficheur LED 7 segments

![7 segments](http://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Seven_segment_02_Pengo.jpg/280px-Seven_segment_02_Pengo.jpg)

Il y a deux sortes d'afficheurs 7 segments

- afficheur à **anode** commune : toutes les anodes sont reliées et connectées au
  potentiel haut. La commande du segment se fait par sa cathode mise au
  potentiel bas.
- afficheur à **cathode** commune : toutes les cathodes sont reliées et connectées
  au potentiel bas.  La commande du segment se fait par son anode mise au
  potentiel haut.


Le kit [*Sunfounder Project Super Starter Kit for Raspberry Pi*](http://www.amazon.fr/gp/product/B00P2E9W30?psc=1&redirect=true&ref_=oh_aui_detailpage_o04_s00)
fournit deux afficheurs à cathode commune, c'est de ce type d'afficheur dont il
est désormais question.

Un afficheur 7 segments (8 en fait si on compte le DP pour *Decimal Point* 
en bas à droite) possède 10 connecteurs.

- deux cathodes communes, on relie l'une d'entre elles à la masse via une
  résistance de 200&#8486;.
- 8 connecteurs qui recevront directement un signal haut ou bas pour allumer ou
  éteindre chacun des segments.

> Remarque : Oui, c'est vrai il y a un problème. En n'utilisant qu'une
> résistance sur la cathode commune, les lois de l'électricité nous apprennent
> que l'intensité pour chacun des segments va dépendre du nombre de segments
> allumés : un `1` avec ses 2 segments allumés sera 3 fois plus lumineux qu'un
> `0` avec ses 6 segments allumés.   
> Le montage correct consiste à relier une des deux cathodes communes à la
> masse et connecter les 8 segments via chacun une résistance de 200&#8486;.   
> Voir à ce sujet [un article en anglais très clair](http://melabs.com/resources/articles/ledart.htm)


Pour commander les 7 segments de l'afficheur, on devrait utiliser 7 broches GPIO.
Ce n'est pas ainsi qu'on va procéder, nous allons voir comment multiplexer 
l'afficheur 7 Segments avec un registre à décalage 74HC595N.

### Le registre à décalage 74HC595N

![74HC595N]({{ site.baseurl }}/images/7segments/74hc595n.jpeg){: .center-image }


![74HC595N schema]({{ site.baseurl }}/images/7segments/74HC595N.png)    
(image issue de [DatasheetCatalog.com](http://www.datasheetcatalog.com/datasheets_pdf/7/4/H/C/74HC595N.shtml) )

- la broche 8 `GND` est reliée à la masse
- la broche 16 `VCC` est reliée au +5V
- Les 8 sorties, de `Q0` à `Q7` vont être connectées aux segments de
  l'afficheur à LED.

Le principe de fonctionnement est le suivant (image issue de [DatasheetCatalog.com](http://www.datasheetcatalog.com/datasheets_pdf/7/4/H/C/74HC595N.shtml) )

À chaque pulsation sur l'horloge (broche 11 `SHCP`), l'état HIGH ou LOW de
l'entrée série (broche 14 `DS`) est enregistré dans le STORAGE REGISTER et les
bits précedement enregistrés sont décalés d'un cran

Durant les opérations d'enregistrement des données, rien ne semble se passer ;
ceci grâce au loquet : *latch* en anglais (broche 12 `STCP`).  Tant que le
*latch* est LOW, les sorties restent dans leur état, mais s'il passe à
HIGH, il commande l'application des valeurs des 8 bits du STORAGE REGISTER aux
8 sorties `Q0` à `Q7`.




